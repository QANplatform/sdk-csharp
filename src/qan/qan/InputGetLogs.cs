/*
 * QAN AutoApi
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.2
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = qan.Client.OpenAPIDateConverter;

namespace qan.qan
{
    /// <summary>
    /// InputGetLogs
    /// </summary>
    [DataContract(Name = "Input_getLogs")]
    public partial class InputGetLogs : IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="InputGetLogs" /> class.
        /// </summary>
        /// <param name="address">The contract address or a list of addresses from which logs should originate.</param>
        /// <param name="blockHash">With the addition of EIP-234, blockHash is a new filter option that restricts the logs returned to the block number referenced in the blockHash. Using the blockHash field is equivalent to setting the fromBlock and toBlock to the block number the blockHash references. If blockHash is present in the filter criteria, neither fromBlock nor toBlock is allowed.</param>
        /// <param name="fromBlock">The block number as a string in decimal format or tags. The supported tag values include earliest for the earliest/genesis block, latest for the latest mined block, pending for the pending state/transactions..</param>
        /// <param name="toBlock">The block number as a string in decimal format or tags. The supported tag values include earliest for the earliest/genesis block, latest for the latest mined block, pending for the pending state/transactions..</param>
        /// <param name="topics">An array of DATA topics and also, the topics are order-dependent. Visit this official page to learn more about topics.</param>
        public InputGetLogs(string address = default(string), string blockHash = default(string), string fromBlock = default(string), string toBlock = default(string), List<string> topics = default(List<string>))
        {
            this.Address = address;
            this.BlockHash = blockHash;
            this.FromBlock = fromBlock;
            this.ToBlock = toBlock;
            this.Topics = topics;
        }

        /// <summary>
        /// A URL to the JSON Schema for this object.
        /// </summary>
        /// <value>A URL to the JSON Schema for this object.</value>
        [DataMember(Name = "$schema", EmitDefaultValue = false)]
        public string Schema { get; private set; }

        /// <summary>
        /// Returns false as Schema should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeSchema()
        {
            return false;
        }
        /// <summary>
        /// The contract address or a list of addresses from which logs should originate
        /// </summary>
        /// <value>The contract address or a list of addresses from which logs should originate</value>
        [DataMember(Name = "Address", EmitDefaultValue = false)]
        public string Address { get; set; }

        /// <summary>
        /// With the addition of EIP-234, blockHash is a new filter option that restricts the logs returned to the block number referenced in the blockHash. Using the blockHash field is equivalent to setting the fromBlock and toBlock to the block number the blockHash references. If blockHash is present in the filter criteria, neither fromBlock nor toBlock is allowed
        /// </summary>
        /// <value>With the addition of EIP-234, blockHash is a new filter option that restricts the logs returned to the block number referenced in the blockHash. Using the blockHash field is equivalent to setting the fromBlock and toBlock to the block number the blockHash references. If blockHash is present in the filter criteria, neither fromBlock nor toBlock is allowed</value>
        [DataMember(Name = "BlockHash", EmitDefaultValue = false)]
        public string BlockHash { get; set; }

        /// <summary>
        /// The block number as a string in decimal format or tags. The supported tag values include earliest for the earliest/genesis block, latest for the latest mined block, pending for the pending state/transactions.
        /// </summary>
        /// <value>The block number as a string in decimal format or tags. The supported tag values include earliest for the earliest/genesis block, latest for the latest mined block, pending for the pending state/transactions.</value>
        [DataMember(Name = "FromBlock", EmitDefaultValue = false)]
        public string FromBlock { get; set; }

        /// <summary>
        /// The block number as a string in decimal format or tags. The supported tag values include earliest for the earliest/genesis block, latest for the latest mined block, pending for the pending state/transactions.
        /// </summary>
        /// <value>The block number as a string in decimal format or tags. The supported tag values include earliest for the earliest/genesis block, latest for the latest mined block, pending for the pending state/transactions.</value>
        [DataMember(Name = "ToBlock", EmitDefaultValue = false)]
        public string ToBlock { get; set; }

        /// <summary>
        /// An array of DATA topics and also, the topics are order-dependent. Visit this official page to learn more about topics
        /// </summary>
        /// <value>An array of DATA topics and also, the topics are order-dependent. Visit this official page to learn more about topics</value>
        [DataMember(Name = "Topics", EmitDefaultValue = false)]
        public List<string> Topics { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class InputGetLogs {\n");
            sb.Append("  Schema: ").Append(Schema).Append("\n");
            sb.Append("  Address: ").Append(Address).Append("\n");
            sb.Append("  BlockHash: ").Append(BlockHash).Append("\n");
            sb.Append("  FromBlock: ").Append(FromBlock).Append("\n");
            sb.Append("  ToBlock: ").Append(ToBlock).Append("\n");
            sb.Append("  Topics: ").Append(Topics).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

}
